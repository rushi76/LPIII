------------------------------------------------------------
DAA PRACTICAL 2
------------------------------------------------------------
Title of the Assignment:
Write a program to implement Huffman Encoding using a greedy strategy.

Objective of the Assignment:
Students should be able to understand and solve Huffman Encoding
using the greedy method.

------------------------------------------------------------
CODE:
------------------------------------------------------------
import heapq

# Create a Node class to store character and frequency
class node:
    def __init__(self, freq, symbol, left=None, right=None):
        self.freq = freq
        self.symbol = symbol
        self.left = left
        self.right = right
        self.huff = ""
    
    # comparison method for heap operations
    def __lt__(self, other):
        return self.freq < other.freq

# Recursive function to print Huffman codes
def printNodes(node, val=""):
    newval = val + node.huff
    if node.left:
        printNodes(node.left, newval)
    if node.right:
        printNodes(node.right, newval)
    else:
        print(f"{node.symbol} -> {newval}")

# Input data: characters and their frequencies
chars = ["a", "b", "c", "d", "e", "f"]
freqs = [5, 9, 12, 13, 16, 45]
nodes = []

# Create leaf nodes and push them into priority queue (min-heap)
for i in range(len(chars)):
    heapq.heappush(nodes, node(freqs[i], chars[i]))

# Repeat until only one node remains (root of Huffman Tree)
while len(nodes) > 1:
    left = heapq.heappop(nodes)
    right = heapq.heappop(nodes)

    left.huff = "0"
    right.huff = "1"

    # Combine two smallest nodes to create a new node
    newnode = node(left.freq + right.freq, left.symbol + right.symbol, left, right)
    heapq.heappush(nodes, newnode)

# Print Huffman Codes
printNodes(nodes[0])

------------------------------------------------------------
SAMPLE OUTPUT:
------------------------------------------------------------
f -> 0
c -> 100
d -> 101
a -> 1100
b -> 1101
e -> 111

(Note: Output may vary slightly in order, but codes will follow Huffman rule.)

------------------------------------------------------------
THEORY / ALGORITHM:
------------------------------------------------------------
1. Create a leaf node for each character and insert it into a min-heap.
2. Extract two nodes with the smallest frequency.
3. Create a new internal node with frequency = sum of both nodes.
4. Assign '0' to left edge and '1' to right edge.
5. Insert this new node back into the min-heap.
6. Repeat steps 2–5 until only one node remains (root of Huffman Tree).
7. The binary codes from root to leaf give the Huffman Encoding.

------------------------------------------------------------
ANALYSIS:
------------------------------------------------------------
• Approach: Greedy Algorithm
• Time Complexity: O(n log n)
   - Each insertion/extraction from the heap takes O(log n)
• Space Complexity: O(n)
   - For storing nodes and Huffman tree
• Optimal Prefix Codes: No code is a prefix of another code.

------------------------------------------------------------
CONCLUSION:
------------------------------------------------------------
Huffman Encoding is an optimal greedy algorithm for data compression.
It assigns shorter binary codes to more frequent characters and longer
codes to less frequent ones, minimizing the total number of bits used
for encoding.

------------------------------------------------------------
VIVA QUESTIONS:
------------------------------------------------------------
Q1. What is Huffman Encoding?
→ It is a lossless data compression algorithm based on frequency of characters.

Q2. Which strategy does it use?
→ Greedy strategy — always combines two least frequent nodes first.

Q3. Why is Huffman Encoding optimal?
→ Because it produces prefix-free binary codes with minimum total cost.

Q4. What is the time complexity?
→ O(n log n), due to heap operations.

Q5. What is the difference between left and right edges?
→ Left edge is assigned '0' and right edge is assigned '1' in the Huffman tree.

Q6. Applications of Huffman Encoding?
→ Used in ZIP file compression, JPEG image format, and text compression.

------------------------------------------------------------
